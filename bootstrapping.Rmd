---
title: "Bootstrapping ziCPUE data"
author: "Lucas A. Nell"
date: "March 31, 2016"
output:
  html_document:
    highlight: haddock
    theme: journal
  pdf_document:
    highlight: haddock
    latex_engine: xelatex
geometry: margin=1in
fontsize: 12pt
mainfont: Helvetica
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE)
```


# Initial setup

The following packages are required:

```{r packages}
library('dplyr', quietly = TRUE)
library('readxl')
library('ggplot2')
library('boot')
library('broom')
library('RColorBrewer')
```


Read, clean, and add necessary columns to the table in `brett_example.xlsx`.

```{r inputData}
CPUE_df <- read_excel("brett_example.xlsx",1) %>% 
  rename(Area = `Effort m^2`, Count = SumOfSPEC) %>%
  filter(Year %in% 1993:2013, !is.na(Year), Month == 10, !is.na(Month)) %>%
  select(Year, Month, Station, Count, Area) %>%
  mutate(CPUE = (Count/Area)*100) %>% 
  arrange(Year)
```



To have better control of bootstrapping within `ggplot2` plots, the following function
allows you to use bootstrapping and CI calculations via the `boot` package. The 
`CI_method` parameter takes the following inputs, inherited from the `boot.ci` function:
"norm","basic", "stud", "perc", or "bca".

``` {r ggBootCI}
ggBootCI <- function(inputData, B = 1e4, CI_method = 'bca'){
  # List names in the `boot.ci` output for these methods differ from their input names
  if (method %in% c('norm', 'stud', 'perc')){
    outListMethod <- gsub('norm', 'normal', method) %>%
      gsub('stud', 'student', .) %>%
      gsub('perc', 'percent', .)
  } else {
    outListMethod <- method
  }
  # Inner function to compute mean and variance of the sampling distribution of the mean
  # for each bootstrap replication
  btMean <- function(inputData, ind){
    m <- mean(inputData[ind])
    n <- length(ind)
    v <- var(inputData[ind]) / n
    return(c(m, n))
  }
  
  bootstraps <- boot(inputData, statistic = btMean, R = B)
  
  # If all resamples return the same value, output df will simply be that value x3:
  if (diff(range(bootstraps$t)) == 0){
    result <- range(bootstraps$t)[1] %>%
      data.frame(ymin = ., y = ., ymax = .)
  } else { # If not, then run `boot.ci`:
    boot.ci_output <- boot.ci(bootstraps, type = method)
    bootCI <- rev(boot.ci_output[[outListMethod]])[c(2,1)]
    result <- data.frame(ymin = bootCI[1], 
                         y = median(bootstraps$t), 
                         ymax = bootCI[2])
  }
  
  return(result)
}
```


For bootstrapping seamlessly with `dplyr`, the package `broom` provides the function
`boostrap`. However, this function samples from all columns regardless of grouping. I've
hacked the original function (found [here](
https://cran.r-project.org/web/packages/broom/vignettes/bootstrapping.html)) to sample 
within a given grouping. Let's say, for example, you group by a variable called `type` 
and in the original sample, `type`s 1, 2, and 3  have sample sizes of 10, 20, and 30,
respectively. This function would randomly sample  exactly 10 items from the original 
dataset (with replacement) that are of `type` 1, 20 of `type` 2, and 30 of `type` 3.

```{r bootstrappingFuns}
# Function to sample row numbers from a numeric vector of sample sizes by group
stratSample <- function(group_n){
  ends <- cumsum(group_n)
  starts <- c(1, ends[-length(ends)] - 1)
  bootRows <- unlist(lapply(seq(length(ends)), function(i){
    sample(seq(starts[i], ends[i]), replace = TRUE)}))
  return(bootRows)
}


stratBootstrap <- function(df, m, group) {
  
  df <- df %>% arrange_(group)
  
  n <- nrow(df)
  group_n <- (df %>% 
    group_by_(group) %>% 
    summarize(n = length(CPUE)))[['n']]
  
  attr(df, "indices") <- replicate(m, stratSample(group_n) - 1, 
                                   simplify = FALSE)
  attr(df, "drop") <- TRUE
  attr(df, "group_sizes") <- rep(n, m)
  attr(df, "biggest_group_size") <- n
  attr(df, "labels") <- data.frame(replicate = 1:m)
  attr(df, "vars") <- list(quote(replicate))
  class(df) <- c("grouped_df", "tbl_df", "tbl", "data.frame")
  
  df
}


```





```{r bootstrapping}
# Bootstrapping mean CPUE values
set.seed(9721)
CPUE_boot <- CPUE_df %>%
  stratBootstrap(1000, group = 'Year') %>%
  do(summarize(group_by(., Year), CPUE = mean(CPUE))) %>% 
  # To strip attributes:
  as.data.frame %>% as.tbl

CPUE_bootSumm <- CPUE_boot %>%
  group_by(Year) %>%
  summarise(low = quantile(CPUE, probs = 0.025),
            mid = quantile(CPUE, probs = 0.5),
            high = quantile(CPUE, probs = 0.975))

CPUE_bootSumm
```




```{r plots}

# Minimal ggplot2 theme
plotTheme <- function(base_size = 10, base_family = 'Helvetica') {
  theme_minimal(base_size = base_size, base_family = base_family) %+replace%
    theme(
      strip.text = element_text(face = 'bold'),
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.major.y = element_line(color = 'gray50', size = 0.125, linetype = 3),
      panel.border = element_rect(fill = NA, color = "gray50"),
      axis.ticks = element_line(color = "gray50"),
      axis.ticks.length = unit(2, 'points'),
      legend.position = 'none'
    )
}

# Color palette for Year
myPalette <- CPUE_df$Year %>% 
  unique %>% length %>% 
  colorRampPalette(brewer.pal(8,  'Dark2'))(.)


bootPlot <- CPUE_df %>%
  ggplot(aes(x = factor(Year), y = CPUE, color = factor(Year))) +
  plotTheme() +
  scale_y_continuous(expression(Mean ~ Catch ~ 100 ~ m^{-2}), trans = 'log10',
                     breaks = c(0.001, 0.01, 0.1, 1, 10, 100, 1000), 
                     limits = c(0.001, 1000),
                     labels = function(n){format(n, scientific = FALSE, 
                                                 drop0trailing = TRUE)}) +
  scale_x_discrete('Year', breaks = seq(min(CPUE_df$Year), max(CPUE_df$Year))) +
  scale_color_manual(values = myPalette)

bootPlot +
  # geom_point(position = position_jitter(width = 0.3, height = 0), 
  #            alpha = 0.4, shape = 16) + 
  # stat_summary(fun.data = "ggBootCI",
  #              fun.args = list(B = 1e4, method = 'perc'),
  #              geom = "errorbar", width = 0.25, size = 0.75) +
  geom_errorbar(data = CPUE_bootSumm, inherit.aes = FALSE, 
                aes(ymin = low, ymax = high, x = factor(Year), 
                    color = factor(Year)),
                width = 0.25, size = 0.75) +
  geom_point(data = CPUE_bootSumm, aes(y = mid), 
             shape = 23, size = 3)


```


```{r testing}






```







